\section{Transmission Control Protocol}
Another popular transport layer protocol implementation is
\emph{transmission control protocol}, TCP. TCP is reliable,
bytestream abstracted, and connection-oriented in exactly
the opposite sense of UDP. Reliable means that TCP implements
application multiplexing, ACKs and retransmissions, flow control,
and congestion control. Bytestream is the familiar concept of
communicating using a byte stream abstraction instead of packets.
Connection-oriented means a pairwise sender to receiver connection
is established before sending data and used to maintain connection-specific
state like initial sequence number, window scaling factor, window size, and more.

\subsection{TCP Header}

A TCP header includes the following
fields:
\begin{itemize}
    \item Source port.
    \item Destination port.
    \item Sequence number.
    \item Acknowledgement.
    \item HdrLen, length of the TCP header in number of 4-byte words. Minimum value of 5.
    \item 0.
    \item Flags.
    \item Advertised window.
    \item Checksum. 16 bits for error detection caused by bit corruption.
    \item Urgent pointer.
    \item Options.
\end{itemize}

The checksum for TCP is interesting. It's calculated over
a pseudo IP header,
the TCP header, and the payload. The pseudo IP header is
extracted from the IP header and includes the source IP,
the destination IP, a fixed 8 bit string of 0s, the 8-bit
protocol field, and the 16-bit TCP packet length. TCP
connection state is defined using a 5-tuple of source IP,
destination IP, source port, destination port, and protocol,
so the purpose of the pseudo IP header is to ensure the
source and destination IP, plus the protocol fields are not
corrupted.

\subsection{Receive Buffers}
The TCP receiver allocates a receive buffer to hold incoming bytes until the application reads them.
The advertised window field in the TCP header tells the sender how much free space remains in that
buffer and is used for per-connection flow control. TCP uses cumulative ACKs: the acknowledgement
number reports the highest contiguous byte received and delivered to the application. Segments that
arrive out of order can be buffered by the receiver, but they do not advance the cumulative ACK until
the gap is filled; the receiver will commonly send duplicate ACKs (repeating the same acknowledgement
number) to indicate the missing byte range.

On the sender side, transmitted but unacknowledged bytes are kept in a send buffer. Loss detection
uses two mechanisms: duplicate ACKs and timers. Receipt of three duplicate ACKs triggers a fast retransmit
of the missing byte(s) (avoiding the slow timeout path) because repeated ACKs imply a hole in the receiver's
byte stream; waiting for three helps avoid retransmitting for transient reordering. If no ACKs arrive
(for example when a single packet or the final packet is lost) a retransmission timeout (RTO) fires and
the sender retransmits the oldest unacknowledged byte. Most TCP implementations maintain one retransmission
timer per connection, reset it when new data is ACKed, and compute RTO from measured RTTs using conservative
estimates to avoid spurious retransmits. With TCP's cumulative-ACK semantics, retransmission typically follows
a Go-Back-N behavior: the sender restarts transmission from the first unacknowledged byte and proceeds from there.

\subsection{TCP Connection}

A TCP connection is identified with a 5-tuple of
source IP, destination IP, source port, destination port, and
protocol (which is always TCP). Connection set up is used to
exchange the \emph{initial sequence number} (ISN), as well
as exchange the window scaling factor. A receiver needs to
know the ISN of the sender to figure out which sequence number
marks the start of the byte stream being received. Each endpoint
chooses its ISN randomly.

A TCP connection setup is a 3-way handshake. Host A sends a
synchronize packet (SYN) to B. Host B returns a SYN
acknowledgement packet (SYN-ACK) to A. Host A sends an ACK
packet to acknowledge the SYN-ACK.

The reason for this three-way handshale is to establish the
ISNs.
\begin{itemize}
    \item SYN contains sequence number equal to ISN of A, $X$. Its ack field is irrelevant
    \item SYN-ACK contains sequence number equal to ISN of B, $Y$. Its ack field is $X$.
    \item ACK has sequence number of $X+1$, ack is $Y+1$.
\end{itemize}

The special packets SYN and SYN-ACK are distinguished through
flags in the header. The \texttt{flags} field is nine bits,
each of which corresponds to a certain TCP flag.
\begin{tabular}{| c | c |}
    \hline
    Bit no. & Flag \\
    \hline
    0       & FIN  \\
    1       & SYN  \\
    2       & RST  \\
    3       & PSH  \\
    4       & ACK  \\
    5       & URG  \\
    6       & ECE  \\
    7       & CWR  \\
    8       & NS   \\
    \hline
\end{tabular}
\marginnote{The ACK flag bit is always set if the header contains
    a valid acknowledgement number. All TCP packets, except SYN and
    RST-REPLY, have an ACK flag bit set.}

TCP by default can do data batching on both send and receive side.
Batching results in fewer packets sent, but adds delay. Setting the
PSH flag disables batching.

If the URG flag is set, the urgent data in the TCP packet is delivered
to an application immediate, bypassing the receive buffer. The urgent
pointer in the TCP header stores the offset to the last urgent byte in
the TCP segment, starting from the first byte in the segment.

ECE and CWR are used by congestion control protocols that use explicit
congestion notification. NS is experimental.
\marginnote{NS stands for nonce sum, and despite the name is not a
    headcount of the ultra powerful but instead a cryptographic
    measure to protect against accidental or malicious concealment
    of marked packets from the sender.}

When A wants to close the connection, it sends a FIN
packet. B replies with a FIN-ACK. A replies with an ACK.
B closes the connection upon receipt of the ACK, otherwise
it sends the FIN-ACK again. A waits a little longer, seeing
if there's going to be another FIN-ACK, then times out and closes
the connection if none was received.
In the case of the FIN packet, the \texttt{flags} field in the
header would be \texttt{000010001}.

TCP endpoint can close a connection any time by sending a
RST packet. There are two kinds:
\begin{itemize}
    \item RST-ABORT: Generated when a connection is explicitly aborted by an
          endpoint e.g., the socket at the endpoint is being killed
    \item RST-REPLY: Generated on receipt of certain kinds of invalid packets
          (e.g., data packet for a connection that does not exist anymore)
\end{itemize}

\begin{figure}
    \includegraphics{images/tcptimingdiagram.png}
    \caption{TCP Timing Diagram}
    \label{fig:tcptimingdiagram}
\end{figure}

If an endpoint receives a RST-ABORT, it closes the connection
with no ACK. If an endpoint receives data for a closed
connection, it generates RST-REPLY.

\subsection{Flow and Congestion Control}

Senders in TCP maintain a sliding window of size $W$, as seen in
Figure \ref{fig:slidingwindow}.
\begin{figure}
    \includegraphics{images/slidingwindow.png}
    \caption{Sliding Window}
    \label{fig:slidingwindow}
\end{figure}
The sender can have up to $W$ bytes of unACKed data in flight.
The left edge of the window represents the beginning of
in-flight data, which has been sent but not yet ACKed. The window
slides when some data is ACKed to allow more to be sent.
$W$ determines the max rate at which the sender can send, the
rate is approximately $\frac{W}{RTT}$ bytes per second.

The problem of sending data as fast as possible without overloading the
receiver is \emph{flow control}.
The advertised window is a field in the TCP header, and the receiver
sets it to the available receive buffer at the receiver. That is,
the advertised buffer is set to
$\text{recv buff size} - ((\text{next expected byte num} - 1) - \text{last byte num read by app})$.
That is, the receive buffer can drop bytes that have already been read
by the app.

Every sender uses the advertised window from the receiver to set its own
window size $W$. Senders maintain a window called RWND. RWND is set to the
advertised window value. The sender's window size $W$ can be at most RWND,
meaning the sender can have at most RWND unACKed bytes in flight, and can
send at most $\frac{RWND}{RTT}$ bytes per second.

On the receiver side, if the buffer is too big then a lot of data may get queued
at the receiver. If the buffer is too small, then the sender won't be able
to fully use its bandwidth. The optimal size for the buffer is bandwidth delay
product.

The advertised window field in the TCP header is only 16 bits long, limiting
the sender window size to 65,535 bytes. This underuses bandwidth for networks
with large BDP. Therefore, TCP endpoints also exchange a window scaling factor
in the SYN packet during connection set up, and RWND is set to the scaling
factor times the advertised window.

The problem of sending data as fast as possible without overloading the network
is \emph{congestion control}. The sender maintains a congestion window CWND,
the maximum number of unACKed bytes a sender can have in flight. The CWND
is increased upon lack of congestion, and decreased on detecting congestion.
Congestion is detected by the number of packet losses.

The sender's slider window $W$ is set to the minimum of the CWND and RWND to
avoid overflowing the receiver buffer or router/switch buffers.
\marginnote{We talk of CWND in units of maximum segment size, the maximum
    amount of payload data in a TCP packet. Real implementations maintain CWND
    in bytes.}

An oversized window is worse than an undersized window, since too many
packets in the network affects everyone, while a slower sending rate only
affects the sender. Ergo, the appropriate thing to do is gently increase
when uncongested, and rapidly decrease when congested. If duplicate ACKs
are received, then some packets are going through and the window size should
be decreased aggressively, but less aggressively than in the case of a timeout,
which means there were certainly several losses.

The balance that modern TCP implementations take is \emph{additive increase,
    multiplicative decrease}. That is, on the success of the last window of data,
increase the CWND by 1 MSS. On loss detected by 3 duplicate ACKS, set
$CWND = \frac{CWND}{2}$. On loss detected by timeout, immediately drop CWND
to one MSS. The factors aren't importance, but an increase factor of 1 and
decrease factor of 2 works best in practice.

An issue with additive increase is that it ramps up very slowly when there's
no congestion. For instance, consider an RTT of 100 ms and MSS of 1000 bytes.
If there is 1 Mbps of available bandwidth, then
the ideal window size (recall that the ideal window size is BDP) is 12.5 MSS.
If the bandwidth increases to 1Gbps, then it takes 12500 RTTs to get to the
new ideal window size of 12500 MSS.

The mitigation for this is to start with a small congestion window and
increase exponentially, only for as long as CWND is small. After that
transition back to AIMD. We introduce a slow start threshold \texttt{ssthresh}
initialized to a large value, and when the CWND outgrows it, switch from
slow start to additive increase.

To summarize slow start, TCP uses slow start for fast ramp ups when CWND
is very small, and otherwise uses AIMD. Starting with a CWND of 1 and
doubling every RTT, TCP leaves slow start when CWND >= \texttt{ssthresh}
and enters the additive increase phase, where CWND is increased by one
MSS on success of last window of data. Cut CWND to half on three duplicate ACKs,
set \texttt{ssthresh} to the new CWND. Cut CWND all the way to 1 MSS on timeout,
and set \texttt{ssthresh} to the old CWND divided by 2. Never drop CWND below 1 MSS.

Another problem is that congestion avoidance is too slow in
recovering from an isolated loss of three duplicate ACKs.
To optimize, we implement fast recovery. The idea behind
fast recovery is to grant the sender temporary credits
for each duplicate ACK to keep packets in flight.
Each duplicate ACK is received because a new packet is arriving
at the receiver, so the congestion isn't that bad and the loss
was isolated.
When three duplicate ACKs are received, TCP:
\begin{itemize}
    \item enters fast recovery mode,
    \item cuts \texttt{ssthresh} to half of CWND, and
    \item sets CWND to half of CWND plus three (the number of credits for duplicate ACKs received thus far).
\end{itemize}
While in fast recovery, TCP increments CWND by one for
each additional duplicate ACK and exits fast recovery after
receiving a new ACK. On exit, it sets CWND to \texttt{ssthresh},
and starts additive increase back up.