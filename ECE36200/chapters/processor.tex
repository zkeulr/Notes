\section{Single-cycle Processor}

We have used the term \emph{processor} without definition thus far,
hoping that the name would convey the idea of a black box performing
operation on some input and return some output. If we were to formulate
it more concretely, we might call a processor a digital component
that performs operations on an external data source, usually memory or
some other data stream. When implementing a processor
there is freedom to define the clocks per instruction (CPI) and
the length of the clock cycle (cycle time), while the ISA and compiler
determine the number of instructions in a program (instruction count)
and performance of a program.

We assume that one entire instruction is performed per clock cycle.
The general instruction pipeline follows and should be internalized,
as it comes up repeatedly:
\begin{enumerate}
    \item Fetch
    \item Decode operands
    \item Execute
    \item Memory
    \item Writeback
\end{enumerate}

Fetch instructions fetch the instruction, then updates the PC. The PC is updated
at the end of every cycle.

ALU instructions make use of the main ALU to perform arithmetic and logic
operations on data stored in registers. These are R-type instructions.

Load instructions move data from the memory to the register file.
There are I-type instructions.

Store instructions move data from the register file to the memory. These
are S-type instructions.

Conditional branch instructions like \texttt{beq} calculate which branch,
or memory address, to jump to as a result of an operation. They compute
the branch condition and branch target. These are SB-type instructions.

A useful way to represent steps and identify required datapath elements
is \emph{register transfer language} (RTL), which is very close to
assembly and shows the path data takes through the unit
in Figure \ref{fig:datapath}.

\begin{figure}
    \includegraphics{images/datapath.png}
    \caption{Datapath}
    \label{fig:datapath}
\end{figure}

For instance, consider the RTL for a general ALU instruction,
\texttt{R[rd] <- R[rs1] op R[rs2]}. \texttt{op} is an arithmetic
operation like \texttt{+} or \texttt{-}. This describes that
\texttt{Ra}, \texttt{Rb}, \texttt{Rw} come from the instruction's
\texttt{rs1}, \texttt{rs2}, and \texttt{rd} fields. The
ALU Operation and RegWr in Figure \ref{fig:datapath} control
logic after decoding the instruction.

The datapath control schematic is shown in Figure \ref{fig:datapathcontrol}.

\begin{figure}
    \includegraphics{images/datapathcontrol.png}
    \caption{Datapath Control}
    \label{fig:datapathcontrol}
\end{figure}

\begin{tabular}{| c | c | c |}
    \hline
    Signal Name & Deassertion Effect                                                              & Assertion Effect                                                                                       \\
    \hline
    RegWrite    & None.                                                                           & The register on the Write register input is written with the value of the Write data input.            \\
    ALUSrc      & The second ALU operand comes from the second register file output.              & The second ALU operand is the sign-extended, 12 bits of the instruction                                \\
    PCSrc       & The PC is replaced by the output of the adder that computes the value of PC + 4 & The PC is replaced by the output of the adder that computes the branch target                          \\
    MemRead     & None                                                                            & Data memory contents designated by the address input are put on the Read data output                   \\
    MemWrite    & None                                                                            & Data memory contents designated by the address input are replaced by the value on the Write data input \\
    MemtoReg    & The value fed to the register Write data input comes from the ALU               & The value fed to the register Write data input comes from the data memory
\end{tabular}

Control signals are the binary commands generated by the control unit to manage CPU operations.
Every instruction requires a specific set of control signals to move data and activate
the right components at the right time.

Consider the ALU as a representative example. In the class we assume the ALU only
supports four operations.
\begin{tabular}{| c | c |}
    \hline
    ALU Control Lines & Function \\
    \hline
    0000              & AND      \\
    0001              & OR       \\
    0010              & add      \\
    0110              & subtract \\
    \hline
\end{tabular}
\marginnote{We use four bits instead of two to represent the operations the ALU can
    perform because on real ALUs more operations are supported.}
We create a control signal called ALUOp. There are three different scenarios for
ALU operation, \texttt{lw}/\texttt{sw}, \texttt{beq}, and R-type. Depending on
the func field in the R-type instruction, the appropriate ALU control input signals
can be generated.
\begin{tabular}{| c | c | c | c | c | c | c |}
    \hline
    Instruction opcode & ALUOp & Operation       & Funct7 field & Funct3 field & Desired ALU action & ALU control input \\
    \hline
    lw                 & 00    & load word       & XXXXXXX      & XXX          & add                & 0010              \\
    sw                 & 00    & store word      & XXXXXXX      & XXX          & add                & 0010              \\
    beq                & 01    & branch if equal & XXXXXXX      & XXX          & subtract           & 0110              \\
    R-type             & 10    & add             & 0000000      & 000          & add                & 0010              \\
    R-type             & 10    & sub             & 0100000      & 000          & subtract           & 0110              \\
    R-type             & 10    & and             & 0000000      & 111          & AND                & 0000              \\
    R-type             & 10    & or              & 0000000      & 110          & OR                 & 0001              \\
    \hline
\end{tabular}

The immediate generator takes in the instruction and spits out a 32-bit immediate.

The cycle time for a single-cycle processor must be long
enough to accommodate the length of the longest instruction,
which is the one with the longest critical path through the
datapath, which in this case is \texttt{lw}. This is unfortunate
because all instructions take as much time as the slowest.
Real computers have multi-cycle processors to deal with this,
and the fact that real memory is slower than our idealized memory.